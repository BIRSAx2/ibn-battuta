use clap::Parser;
use ibn_battuta::algorithms::*;
use ibn_battuta::parser::TspBuilder;
use std::path::PathBuf;

#[derive(Parser)]
#[clap(
    name = "TSP Solver",
    version = "1.0",
    author = "Your Name",
    about = "Solves Traveling Salesman Problem instances using various algorithms"
)]
struct Cli {
    #[clap(short, long)]
    instance: PathBuf,

    #[clap(short, long, default_value = "64")]
    threads: usize,

    #[clap(subcommand)]
    algorithm: Algorithm,
}

#[derive(Parser)]
enum Algorithm {
    #[clap(
        name = "nearest-neighbor",
        alias = "nn",
        alias = "nearest",
        about = "Nearest Neighbor algorithm"
    )]
    NearestNeighbor,

    #[clap(
        name = "two-opt",
        alias = "2-opt",
        about = "2-opt algorithm based on the tour generated by the Nearest Neighbor algorithm"
    )]
    TwoOpt,

    #[clap(
        name = "simulated-annealing",
        alias = "sa",
        about = "Simulated Annealing algorithm"
    )]
    SimulatedAnnealing {
        #[clap(
            long,
            default_value = "1000.0",
            help = "Initial temperature for the annealing process"
        )]
        initial_temp: f64,
        #[clap(long, default_value = "0.999", help = "Cooling rate for the annealing process")]
        cooling_rate: f64,
        #[clap(
            long,
            default_value = "0.0001",
            help = "Minimum temperature to stop the annealing process"
        )]
        min_temp: f64,
        #[clap(long, default_value = "1000", help = "Maximum number of iterations")]
        max_iter: usize,
        #[clap(long, default_value = "100", help = "Number of cycles per temperature")]
        cycles_per_temp: usize,
    },

    #[clap(
        name = "genetic-algorithm",
        alias = "ga",
        about = "Genetic Algorithm for solving the TSP"
    )]
    GeneticAlgorithm {
        #[clap(long, default_value = "100", help = "Population size")]
        pop_size: usize,
        #[clap(long, default_value = "5", help = "Tournament size for selection")]
        tournament_size: usize,
        #[clap(long, default_value = "0.01", help = "Mutation rate")]
        mutation_rate: f64,
        #[clap(long, default_value = "1000", help = "Maximum number of generations")]
        max_gen: usize,
    },
    #[clap(
        name = "ant-colony-system",
        alias = "acs",
        about = "Ant Colony System algorithm for solving the TSP"
    )]
    AntColonySystem {
        #[clap(long, default_value = "0.1", help = "Pheromone importance")]
        alpha: f64,
        #[clap(long, default_value = "2.0", help = "Heuristic importance")]
        beta: f64,
        #[clap(long, default_value = "0.1", help = "Pheromone evaporation rate")]
        rho: f64,
        #[clap(long, default_value = "0.9", help = "Probability of choosing the best path")]
        q0: f64,
        #[clap(long, default_value = "1000", help = "Maximum number of iterations")]
        max_iter: usize,
    },

    #[clap(
        name = "red-black-acs",
        alias = "rb-acs",
        about = "Red-Black Ant Colony System algorithm for solving the TSP"
    )]
    RedBlackACS {
        #[clap(long, default_value = "1.0", help = "Pheromone importance for red ants")]
        alpha: f64,
        #[clap(long, default_value = "2.0", help = "Heuristic importance for red ants")]
        beta: f64,
        #[clap(long, default_value = "0.1", help = "Pheromone evaporation rate for red ants")]
        rho_red: f64,
        #[clap(long, default_value = "0.2", help = "Pheromone evaporation rate for black ants")]
        rho_black: f64,
        #[clap(long, default_value = "0.9", help = "Probability of choosing the best path")]
        q0: f64,
        #[clap(long, default_value = "20", help = "Number of ants")]
        num_ants: usize,
        #[clap(long, default_value = "1000", help = "Maximum number of iterations")]
        max_iter: usize,
    },

    #[clap(
        name = "ant-system",
        alias = "as",
        about = "Ant System algorithm for solving the TSP"
    )]
    AntSystem {
        #[clap(long, default_value = "1.0", help = "Pheromone importance")]
        alpha: f64,
        #[clap(long, default_value = "2.0", help = "Heuristic importance")]
        beta: f64,
        #[clap(long, default_value = "0.5", help = "Pheromone evaporation rate")]
        rho: f64,
        #[clap(long, default_value = "20", help = "Number of ants")]
        num_ants: usize,
        #[clap(long, default_value = "1000", help = "Maximum number of iterations")]
        max_iter: usize,
    },
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    // Set the number of threads
    rayon::ThreadPoolBuilder::new()
        .num_threads(cli.threads)
        .build_global()?;

    // Parse the TSP instance
    let tsp = TspBuilder::parse_path(&cli.instance).unwrap();

    // Create and run the appropriate solver
    let mut solver: Box<dyn TspSolver> = match cli.algorithm {
        Algorithm::NearestNeighbor => Box::new(NearestNeighbor::new(tsp)),
        Algorithm::TwoOpt => Box::new(TwoOpt::new(tsp)),
        Algorithm::SimulatedAnnealing { initial_temp, cooling_rate, min_temp, max_iter, cycles_per_temp } => {
            Box::new(SimulatedAnnealing::with_options(tsp, initial_temp, cooling_rate, min_temp, max_iter, cycles_per_temp))
        }
        Algorithm::GeneticAlgorithm { pop_size, tournament_size, mutation_rate, max_gen } => {
            Box::new(GeneticAlgorithm::with_options(tsp, pop_size, tournament_size, mutation_rate, max_gen))
        }
        Algorithm::AntColonySystem { alpha, beta, rho, q0, max_iter } => {
            Box::new(AntColonySystem::with_options(tsp, alpha, beta, rho, q0, 20, max_iter))
        }
        Algorithm::RedBlackACS { alpha, beta, rho_red, rho_black, q0, num_ants, max_iter } => {
            Box::new(RedBlackACS::new(tsp, alpha, beta, rho_red, rho_black, q0, num_ants, max_iter))
        }
        Algorithm::AntSystem { alpha, beta, rho, num_ants, max_iter } => {
            Box::new(AntSystem::with_options(tsp, alpha, beta, rho, num_ants, max_iter))
        }
    };

    // Solve the TSP instance
    let solution = solver.solve();

    // Print the results
    println!("Algorithm: {}", solver);
    println!("Tour length: {:.2}", solution.total);
    println!("Tour: {:?}", solution.tour);

    Ok(())
}